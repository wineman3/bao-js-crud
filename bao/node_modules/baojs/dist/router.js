"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Router_router;
Object.defineProperty(exports, "__esModule", { value: true });
const middleware_1 = require("./middleware");
const router_1 = require("./router/router");
class Router {
    constructor() {
        _Router_router.set(this, new router_1.default());
        /**
         * The middleware used by this router
         */
        this.middleware = new middleware_1.default();
    }
    /**
     * Register a route with the router
     *
     * @param method The HTTP method
     * @param path The path of the route
     * @param handler The path handler function
     */
    register(method, path, handler) {
        if (method == "ANY") {
            __classPrivateFieldGet(this, _Router_router, "f").any(path, handler);
        }
        else {
            __classPrivateFieldGet(this, _Router_router, "f").on(method, path, handler);
        }
    }
    /**
     * Handles an incoming request
     *
     * @param ctx The Context object created by the request
     * @returns The Response generated by the path handler and middleware
     */
    async handle(ctx) {
        let method = ctx.method;
        if (method == "HEAD") {
            method = "GET";
        }
        const route = __classPrivateFieldGet(this, _Router_router, "f").find(method, ctx.path);
        // If route not found, send an empty 404
        if (route.handler == null)
            return new Response("404 Not Found", { status: 404 });
        // Assign the route parameters
        ctx.params = route.params;
        // Run the Context through the middleware and route
        ctx = await this.middleware.before(ctx);
        if (!ctx.isLocked())
            ctx = await Promise.resolve(route.handler(ctx));
        if (!ctx.isLocked())
            ctx = await this.middleware.after(ctx);
        // Handle a HEAD request
        if (ctx.method == "HEAD") {
            ctx.res = new Response("", {
                status: ctx.res.status,
                statusText: ctx.res.statusText,
                headers: ctx.res.headers,
            });
        }
        return ctx.res;
    }
}
exports.default = Router;
_Router_router = new WeakMap();
//# sourceMappingURL=router.js.map